import{_ as e,c as d,o as t,a}from"./app.af31bdc2.js";const S=JSON.parse('{"title":"源代码嵌入","description":"","frontmatter":{},"headers":[{"level":2,"title":"二进制标头","slug":"二进制标头","link":"#二进制标头","children":[]},{"level":2,"title":"JSON header","slug":"json-header","link":"#json-header","children":[]},{"level":2,"title":"文本","slug":"文本","link":"#文本","children":[]},{"level":2,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]}],"relativePath":"guide/source-embedding.md","lastUpdated":1675251710000}'),r={name:"guide/source-embedding.md"},o=a('<h1 id="源代码嵌入" tabindex="-1">源代码嵌入 <a class="header-anchor" href="#源代码嵌入" aria-hidden="true">#</a></h1><p>程序源可以嵌入 HEX 文件或任何其他格式。它们与设备上的程序一起闪存，因此如果设备支持读回，则可以从那里恢复。</p><p>本规范是根据设备闪存的内容，而不是特定的文件格式，HEX 或其他。</p><h2 id="二进制标头" tabindex="-1">二进制标头 <a class="header-anchor" href="#二进制标头" aria-hidden="true">#</a></h2><p>标头对齐为 16 字节，位于闪存中的某个位置。所有数字都是无符号小端整数。</p><table><thead><tr><th>Offset</th><th>Size</th><th>Value</th></tr></thead><tbody><tr><td>0</td><td>8</td><td>Magic, &quot;\\x41\\x14\\x0E\\x2F\\xB8\\x2F\\xA2\\xBB&quot;</td></tr><tr><td>8</td><td>2</td><td>JSON header length</td></tr><tr><td>10</td><td>4</td><td>Text length</td></tr><tr><td>14</td><td>2</td><td>Reserved; write as zero</td></tr></tbody></table><p>请注意，文本长度不是自然对齐的。这是由于历史原因（它以前是 16 位长）。</p><p>接下来是 JSON 头和文本（可能是压缩的），两者都具有指定的长度。</p><h2 id="json-header" tabindex="-1">JSON header <a class="header-anchor" href="#json-header" aria-hidden="true">#</a></h2><p>JSON 标头是 UTF8 编码的 JSON，具有以下字段：</p><ul><li><code>eURL</code>(string)：编辑器的 URL</li><li><code>eVER</code>(string)：编辑的 semver</li><li><code>name</code>(string)：脚本的名称（可以通过闪烁的工具显示）</li><li><code>compression</code>(string)：指定压缩方法；可选的</li></ul><p>压缩字段指定文本节的编码。它可以具有以下值之一：</p><ul><li><code>&quot;&quot;</code>（或 null 或省略字段）-无压缩</li><li><code>&quot;LZMA&quot;</code> - LZMA 原始压缩</li></ul><p>编辑器应该经常检查项目是否适合他们（即，<code>eURL</code>和<code>eVER</code>具有合理的值）。如果没有，编辑器应该向用户显示一个对话框，其中包含重定向到<code>eURL</code>（需要再次加载文件的位置）的选项，或者如果可能，则包含尝试在当前编辑器中加载文件的选项。</p><p>可能还有其他特定于编辑器的字段。</p><p>此标头应保持较小，因为它未被压缩。</p><h2 id="文本" tabindex="-1">文本 <a class="header-anchor" href="#文本" aria-hidden="true">#</a></h2><p>本节的解释因编辑而异。</p><p>对于 PXT，文本始终是 LZMA 压缩的。如果 JSON 标头的<code>headerSize</code>字段存在且非零，则解压缩文本的第一个<code>headerSize</code>字符（非字节）包含一个 JSON 对象，该对象逻辑上扩展了 JSON 标头的字段（但已压缩）。未压缩文本的其余部分（或整个文本，如果没有头）是 JSON 文件——项目中所有文件从文件名到文件内容的映射。</p><p>对于脚本语言，文本可以是原始的、未压缩的，并且可以由解释器直接使用。</p><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-hidden="true">#</a></h2><p>较旧版本的 PXT 和 TouchDevelop（在传统的微位编程环境中实现）不使用<code>eURL</code>/<code>eVER</code>。</p><p>如果源对于闪存大小太大，则不会嵌入。</p>',23),i=[o];function c(l,h,n,s,p,u){return t(),d("div",null,i)}const g=e(r,[["render",c]]);export{S as __pageData,g as default};
