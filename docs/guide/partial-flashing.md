# 部分闪烁

### 这是规范草案

当以交互方式工作并频繁刷新设备时，通常只有一小部分程序发生变化（例如，运行时保持不变）。因此，为了获得最佳（最快）用户体验，最好只闪现更改的部分。

如果在计算机、进行闪烁的 MCU 和正在闪烁的 MCU 之间存在快速链接（最后两个可以相同），那么可以只读取每一页，看看是否需要重新闪烁。这是一个非常健壮、简单和有效的解决方案，例如在 MSD 引导加载程序和没有单独接口芯片的情况下，它非常有效。

OTOH，如果某些链接速度较慢，最好包含一些元数据以帮助部分闪烁。在各种无线电连接上尤其如此。

本文档定义了指定闪存区域校验和的格式

## 校验和块

| Offset | Size | Value                                   |
| ------ | ---- | --------------------------------------- |
| 0      | 4    | Magic number: or 0x07eeb07c0x87eeb07c   |
| 4      | 4    | Position of end marker (32-bit aligned) |
| 8      | 4    | End marker value and page size          |
| 12     | 8    | Region 0                                |
| …      | ...  | Region …                                |
| …      | 4    | 0x00000000 - regions terminator         |

所有数字都是 little endian

magic number 表示引导加载程序应该为频繁的重新刷新进行优化（例如，单击重置按钮一次（而不是双击）后启动）。magic number 表示没有这种偏好。`0x87eeb07c` `0x07eeb07c`

结束标记用于减轻部分闪光。它应该是随机的，或者从整个程序的校验和中导出。应将其放置在闪烁过程结束时（通常在程序结束时）写入。闪光过程应检查闪光是否包含指示位置的结束标记。如果没有，整个校验和块应该被视为无效。

结束标记值的低位字节应包含页面大小，以 2 的幂表示。如果结束标记为，则页面大小为`X` `1 << (X & 0xff)`

### 区域描述符

| Offset | Size | Value                         |
| ------ | ---- | ----------------------------- |
| 0      | 2    | First page                    |
| 2      | 2    | Number of pages               |
| 4      | 4    | Application-specific checksum |

应用程序可以以任何方式计算校验和。例如，可以获取区域内容的 SHA256 的前 4 个字节。

不需要区域描述符来覆盖整个闪存，甚至闪存文件的整个内容。如果闪存文件中没有给定位置的区域描述符，则应始终闪存该位置。

## 典型用途

例如，在 micro:bit 中将具有以下区域：引导加载器+软设备 DAL+编译的 C++代码\*用户代码

在 SAMD21 上，没有引导加载程序和软设备区域，因为引导加载程序通常不包含在.UF2 文件中，并且没有软设备。

用户代码的校验和可以包含，也可以不包含。它可以防止完全相同的用户代码重新闪烁，但这不是一个非常常见的使用场景。

## 校验和块的位置
校验和块的位置是MCU特定的。
- SAMD21 -（在应用向量之后，加上Arduino保留的一个单词）`0x20B4`
- nRF51 -（在UICR中继续）`0x100010C0` `CUSTOMER[16]`