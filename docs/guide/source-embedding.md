# 源代码嵌入

程序源可以嵌入 HEX 文件或任何其他格式。它们与设备上的程序一起闪存，因此如果设备支持读回，则可以从那里恢复。

本规范是根据设备闪存的内容，而不是特定的文件格式，HEX 或其他。

## 二进制标头

标头对齐为 16 字节，位于闪存中的某个位置。所有数字都是无符号小端整数。

| Offset | Size | Value                                     |
| ------ | ---- | ----------------------------------------- |
| 0      | 8    | Magic, "\x41\x14\x0E\x2F\xB8\x2F\xA2\xBB" |
| 8      | 2    | JSON header length                        |
| 10     | 4    | Text length                               |
| 14     | 2    | Reserved; write as zero                   |

请注意，文本长度不是自然对齐的。这是由于历史原因（它以前是 16 位长）。

接下来是 JSON 头和文本（可能是压缩的），两者都具有指定的长度。

## JSON header

JSON 标头是 UTF8 编码的 JSON，具有以下字段：

- `eURL`(string)：编辑器的 URL
- `eVER`(string)：编辑的 semver
- `name`(string)：脚本的名称（可以通过闪烁的工具显示）
- `compression`(string)：指定压缩方法；可选的

压缩字段指定文本节的编码。它可以具有以下值之一：

- `""`（或 null 或省略字段）-无压缩
- `"LZMA"` - LZMA 原始压缩

编辑器应该经常检查项目是否适合他们（即，`eURL`和`eVER`具有合理的值）。如果没有，编辑器应该向用户显示一个对话框，其中包含重定向到`eURL`（需要再次加载文件的位置）的选项，或者如果可能，则包含尝试在当前编辑器中加载文件的选项。

可能还有其他特定于编辑器的字段。

此标头应保持较小，因为它未被压缩。

## 文本

本节的解释因编辑而异。

对于 PXT，文本始终是 LZMA 压缩的。如果 JSON 标头的`headerSize`字段存在且非零，则解压缩文本的第一个`headerSize`字符（非字节）包含一个 JSON 对象，该对象逻辑上扩展了 JSON 标头的字段（但已压缩）。未压缩文本的其余部分（或整个文本，如果没有头）是 JSON 文件——项目中所有文件从文件名到文件内容的映射。

对于脚本语言，文本可以是原始的、未压缩的，并且可以由解释器直接使用。

## 注意事项

较旧版本的 PXT 和 TouchDevelop（在传统的微位编程环境中实现）不使用`eURL`/`eVER`。

如果源对于闪存大小太大，则不会嵌入。
